#ifdef GL_ES
precision highp float;
#endif

		#extension GL_OES_standard_derivatives : enable
#define pi2 3.1415926535897932384626433832795
// glslsandbox uniforms
uniform float time;
uniform vec2 resolution;
uniform vec2 mouse;
// shadertoy globals
#define iTime time
#define iResolution resolution
#define iMouse mouse

// GLOBALS

// colors
vec3 col_water = vec3(.1, .1, .1);
float t = 20.;

// marching
float maxdist = 5.;
float det = .001;



// USEFUL LITTLE FUNCTIONS

// 2D rotation
mat2 rot2D(float a) {
  a = radians(a);
  float s = sin(a);
  float c = cos(a);
  return mat2(c, s, -s, c);
}

// Align vector
mat3 lookat(vec3 fw, vec3 up) {
  fw = normalize(fw);
  vec3 rt = normalize(cross(fw, normalize(up)));
  return mat3(rt, cross(rt, fw), fw);
}


// Tile fold 
float fmod(float p, float c) { return abs(c - mod(p, c * 2.)) / c; }

// Smooth min
float smin(float a, float b, float k) {
  float h = clamp(0.1 + 0.5 * (b - a) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// Smooth max
float smax(float a, float b, float k) {
  float h = clamp(0.5 + 0.5 * (a - b) / k, 0.0, 1.0);
  return mix(b, a, h) - k * h * (1.0 - h);
}

// BACKGROUND AND FOREGROUND FRACTAL

float fractal(vec3 p, float time) {
  p += cos(p.z * 3. + time * 4.) * .02;
  float depth = smoothstep(0., 6., -p.z + 5.);
  p *= .3;
  p = abs(2. - mod(p + vec3(0.4, 0.7, time * .07), 4.));
  float ls = 0.;
  float c = 0.;
  for (int i = 0; i < 6; i++) {
    p = abs(p) / min(dot(p, p), 1.) - .9;
    float l = length(p);
    c += abs(l - ls);
    ls = l;
  }
  return .15 + smoothstep(0., 50., c) * depth * 4.;
}

// RAY MARCHING AND SHADING

vec3 march(vec3 from, vec3 dir, vec3 dir_light, float time) {
  vec3 odir = dir;
  vec3 p = from + dir * 2.;
  float fg = fractal(p + dir, time) * .55;
  vec3 col = vec3(0.);
  float totdist = 0.;
  float d;
  float v = 0.;
  
  float fade = smoothstep(maxdist * .2, maxdist * .9, maxdist - totdist);
  float ref = 1.;
  if (d < det * 2.) {
    p -= (det - d) * dir;
    col = mix(col_water * .15, col, fade);
  }
  col *= normalize(col_water + 1.5) * 1.7;
  p = maxdist * dir;
  vec3 bk = fractal(p, time) * ref * col_water;
  float glow = pow(max(0., dot(dir, -dir_light)), 1.5);
  vec3 glow_water = normalize(col_water+1.);
  bk += glow_water*(glow+ pow(glow, 8.) * 1.5) * ref;
  col += v * .06 * glow * ref * glow_water;
  col += bk + fg * col_water;
  return col;
}

// MAIN

void mainImage(out vec4 fragColor, in vec2 fragCoord) 
{
  // Set globals
  float time = mod(iTime, 600.);
  vec3 dir_light = normalize(vec3(-.3, 0.2, 1.));

  // Pixel coordinates
  vec2 uv = fragCoord / iResolution.xy - .5;
  vec2 uv2 = uv;
  float ar = iResolution.x / iResolution.y; 
  uv.x *= ar;

  // Camera
  vec2 emouse = (iMouse.xy / iResolution.xy - .5) * 4.;
  float tcam = (time+67.)*.05;
  float zcam = smoothstep(.7, 1., cos(tcam)) * 1.8 - .3;
  zcam -= smoothstep(.7, 1., -cos(tcam)) * 1.6;
  //if (iMouse.z < 0.1) emouse = vec2(sin(time * .15)*ar, zcam);
  vec3 dir = normalize(vec3(uv, .9));
  vec3 from = vec3(1., 0., -0.5 + mouse.y) * 1.25;
  from.xy *= rot2D(-mouse.x * 40.);
  dir = lookat(normalize(-from+vec3(sin(time*.5)*.3,cos(time*.25)*.1,0.)), vec3(0., 0., -1.)) * dir;

  // March and color
  vec3 col = march(from, dir, dir_light, time);
  col *= vec3(1.1, .9, .8);
  col += dot(uv2, uv2) * vec3(0., 0.6, 1.) * .8;

  // Output to screen
  fragColor = vec4(col, 1.);
}

void main(void)
{
    mainImage(gl_FragColor, gl_FragCoord.xy);
}